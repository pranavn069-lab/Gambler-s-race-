<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Race</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow-y: auto;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 1rem;
            gap: 2rem;
        }

        .game-main {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
        }

        .board-wrapper {
            overflow-x: auto;
            max-width: 100vw;
            border: 2px solid #a0aec0;
            border-radius: 0.5rem;
            padding: 0.5rem;
            background-color: #2d3748;
        }

        #gameBoard {
            display: grid;
            gap: 0.25rem;
            position: relative;
        }

        .tile {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1.25rem;
            border: 2px solid #4a5568;
            border-radius: 0.375rem;
            position: relative;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s ease-in-out;
        }

        .tile:hover {
            transform: translateY(-2px);
        }

        .tile-start { background-color: #38a169; color: #fff; border-color: #2f855a; }
        .tile-finish { background-color: #e53e3e; color: #fff; border-color: #c53030; }
        .tile-negative { background-color: #f6ad55; }
        .tile-action { background-color: #63b3ed; }
        .tile-normal { background-color: #e2e8f0; color: #2d3748; }

        .player {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            position: absolute;
            transition: all 0.5s ease-in-out;
            border: 2px solid #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .player-1 { background-color: #3182ce; top: 5px; }
        .player-2 { background-color: #e53e3e; bottom: 5px; }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 1rem;
            gap: 1rem;
        }

        .dice-container {
            display: flex;
            gap: 1rem;
        }

        .dice {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: bold;
            border-radius: 0.5rem;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            color: #1a202c;
        }

        .dice:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        .dice-green { background-color: #48bb78; }
        .dice-yellow { background-color: #f6e05e; }
        .dice-red { background-color: #e53e3e; }
        .dice:disabled { cursor: not-allowed; opacity: 0.5; }

        button {
            background-color: #4299e1;
            color: #1a202c;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #3182ce;
        }

        button:disabled {
            background-color: #6b7280;
            cursor: not-allowed;
        }

        .message-box {
            background: #2d3748;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
            text-align: center;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            min-height: 50px;
        }

        .action-card-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .card-content {
            background-color: #fff;
            color: #1a202c;
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            width: 80%;
            max-width: 400px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .card-content h3 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }

        .card-content p {
            font-size: 1rem;
            margin-bottom: 1.5rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex items-center justify-center min-h-screen">
    <div class="game-container">
        <div class="game-main">
            <h1 class="text-3xl sm:text-4xl md:text-5xl font-extrabold mb-4 text-center text-blue-400">The Race</h1>
            <div class="board-wrapper">
                <div id="gameBoard" class="relative"></div>
            </div>
            
            <div class="controls mt-8">
                <p class="text-lg">Player <span id="currentPlayerText">1</span>'s turn</p>
                <div class="dice-container" id="diceContainer">
                    <div id="greenDice" class="dice dice-green text-gray-800"></div>
                    <div id="yellowDice" class="dice dice-yellow text-gray-800"></div>
                    <div id="redDice" class="dice dice-red text-gray-800"></div>
                </div>
                <button id="rollDiceBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-colors">Roll Dice</button>
                <button id="refreshBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors">Restart Game</button>
                <div id="messageBox" class="message-box bg-gray-800 text-gray-300 rounded-lg p-4 shadow-md text-center">
                    Welcome! Roll the dice to begin.
                </div>
            </div>
        </div>
    </div>

    <!-- Action Card Modal -->
    <div id="actionCardModal" class="action-card-modal hidden">
        <div class="card-content bg-white text-gray-800 rounded-lg p-8">
            <h3 class="text-2xl font-bold mb-4">Action Card!</h3>
            <p id="actionCardText" class="text-lg mb-6"></p>
            <button id="closeModalBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors">OK</button>
        </div>
    </div>

    <script>
        let players = [{ position: 0, id: 1, skipTurn: false, canOnlyUseGreen: false, canOnlyUseRed: false, hasProtection: false }, { position: 0, id: 2, skipTurn: false, canOnlyUseGreen: false, canOnlyUseRed: false, hasProtection: false }];
        let currentPlayerIndex = 0;
        let chosenDiceType = null;
        let diceResults = { green: 0, yellow: 0, red: 0 };
        const boardData = [];
        let boardPath = [];
        let lastRoll = 0;
        let isChoosingDice = false;
        
        const START_COORD = { row: 13, col: 0 };
        const FINISH_COORD = { row: 1, col: 16 };
        const BOARD_ROWS = 15;
        const BOARD_COLS = 17;

        const actionCards = [
            "Skip opponent's turn",
            "Move forward 3 additional spaces",
            "Your opponent is one step behind you",
            "Move forward one space",
            "Swap position with ur opponent",
            "Odd or even: if odd Move backwards if even Move forward",
            "Double dice: roll Two dice at once and add both numbers rolled.",
            "Trip: Move back the same number you rolled.",
            "Weak roll: can only roll the Green die next turn",
            "Risk Roll: can only roll the red die next turn",
            "6 or nothing: have to roll a 6 to proceed. Red die is unusable.",
            "Protection: roll the dice and if it lands on Negative tile, ignore the effect.",
        ];

        const boardDiv = document.getElementById('gameBoard');
        const greenDiceDiv = document.getElementById('greenDice');
        const yellowDiceDiv = document.getElementById('yellowDice');
        const redDiceDiv = document.getElementById('redDice');
        const rollDiceBtn = document.getElementById('rollDiceBtn');
        const refreshBtn = document.getElementById('refreshBtn');
        const messageBox = document.getElementById('messageBox');
        const currentPlayerText = document.getElementById('currentPlayerText');
        const actionCardModal = document.getElementById('actionCardModal');
        const actionCardText = document.getElementById('actionCardText');
        const closeModalBtn = document.getElementById('closeModalBtn');

        /**
         * Checks if a candidate tile is a valid linear step from the current tile.
         * A tile is a valid step if it is within bounds, not visited, and only
         * connected to the current tile (not any other visited tiles).
         * @param {{row: number, col: number}} current - The current tile's coordinates.
         * @param {{row: number, col: number}} candidate - The potential next tile's coordinates.
         * @param {Set<string>} visited - The set of visited tile coordinates.
         * @returns {boolean} True if the move is a valid linear step, false otherwise.
         */
        function isLinearMove(current, candidate, visited) {
            // Define all four possible directions (used for neighbor check)
            const neighborDirections = [
                { dr: 0, dc: 1 }, { dr: 0, dc: -1 }, // right, left
                { dr: -1, dc: 0 }, { dr: 1, dc: 0 }  // up, down
            ];

            // Count how many neighbors of the candidate tile are already in the path
            let pathNeighborCount = 0;
            for (const move of neighborDirections) {
                const neighbor = { row: candidate.row + move.dr, col: candidate.col + move.dc };
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const currentKey = `${current.row},${current.col}`;
                
                // If the neighbor is in the visited set and it's not the current tile,
                // then this would create a branch.
                if (visited.has(neighborKey) && neighborKey !== currentKey) {
                    return false; // This move would create a branch, reject it.
                }
                
                // If the neighbor IS the current tile, count it
                if (neighborKey === currentKey) {
                    pathNeighborCount++;
                }
            }
            
            // A valid linear move must be connected to exactly one tile already in the path (the current one)
            return pathNeighborCount === 1;
        }

        /**
         * Generates a linear path from start to finish using an iterative, non-recursive approach.
         * The path is designed to be a single, non-branching line with no loops.
         * The algorithm uses backtracking to find a valid path to the finish.
         */
        function generateLinearPath() {
            // Define possible moves with a bias towards moving forward (right and up).
            const directions = [
                { dr: 0, dc: 1 }, // Right
                { dr: -1, dc: 0 }, // Up
                { dr: 1, dc: 0 }  // Down
            ];

            while (true) {
                let path = [{ ...START_COORD }];
                let visited = new Set([`${START_COORD.row},${START_COORD.col}`]);
                let current = { ...START_COORD };

                // Loop to build the path until the finish is reached or we get stuck
                while (path.length < 1000) { // Limit path length to prevent infinite loops
                    let foundNextTile = false;
                    // Randomize directions to create a more varied path
                    const shuffledDirections = [...directions].sort(() => Math.random() - 0.5);

                    for (const move of shuffledDirections) {
                        const next = { row: current.row + move.dr, col: current.col + move.dc };
                        const key = `${next.row},${next.col}`;

                        // Check if the next tile is within board bounds and has not been visited
                        // The key new check is the call to isLinearMove()
                        if (next.row >= 0 && next.row < BOARD_ROWS && next.col >= 0 && next.col < BOARD_COLS && !visited.has(key) && isLinearMove(current, next, visited)) {
                            // Check for finish condition
                            if (next.row === FINISH_COORD.row && next.col === FINISH_COORD.col && path.length > 50) {
                                path.push(next);
                                return path; // Found a valid path!
                            }

                            // Add the new tile to the path and mark it as visited
                            current = next;
                            path.push(current);
                            visited.add(key);
                            foundNextTile = true;
                            break; // Found a valid move, move on to the next step
                        }
                    }

                    if (!foundNextTile) {
                        // If no valid move was found from the current tile, we are in a dead end.
                        // Backtrack by removing the last tile from the path.
                        path.pop();
                        if (path.length === 0) {
                            // If we backtracked all the way to the start, the path is invalid.
                            break; // Restart the entire path generation process
                        }
                        // Set the current tile to the new last tile in the path and try again
                        current = path[path.length - 1];
                    }
                }
            }
        }

        function generateBoardData() {
            const board = Array(BOARD_ROWS).fill(null).map(() => Array(BOARD_COLS).fill(null));
            const tileValues = ['-', 'Action', 'Normal'];
            
            boardPath = generateLinearPath();
            
            for (const pos of boardPath) {
                const value = tileValues[Math.floor(Math.random() * tileValues.length)];
                board[pos.row][pos.col] = value;
            }

            board[START_COORD.row][START_COORD.col] = 'Start';
            board[FINISH_COORD.row][FINISH_COORD.col] = 'Finish';

            return board;
        }

        function renderBoard() {
            boardDiv.innerHTML = '';
            boardDiv.style.gridTemplateRows = `repeat(${BOARD_ROWS}, 1fr)`;
            boardDiv.style.gridTemplateColumns = `repeat(${BOARD_COLS}, 1fr)`;

            for (let r = 0; r < BOARD_ROWS; r++) {
                for (let c = 0; c < BOARD_COLS; c++) {
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    const tileValue = boardData[r][c];
                    
                    if (tileValue) {
                        tile.textContent = tileValue;
                        tile.dataset.row = r;
                        tile.dataset.col = c;
                        if (tileValue === '-') tile.classList.add('tile-negative');
                        else if (tileValue === 'Action') tile.classList.add('tile-action');
                        else if (tileValue === 'Start') tile.classList.add('tile-start');
                        else if (tileValue === 'Finish') tile.classList.add('tile-finish');
                        else if (tileValue === 'Normal') tile.classList.add('tile-normal');
                    } else {
                         // Default styling for tiles not in the path (empty spots)
                         tile.style.backgroundColor = '#1a202c';
                         tile.style.border = 'none';
                         tile.style.boxShadow = 'none';
                    }
                    boardDiv.appendChild(tile);
                }
            }
            positionPlayers();
        }
        
        function positionPlayers() {
            const tiles = boardDiv.querySelectorAll('.tile');
            tiles.forEach(tile => {
                const existingPlayers = tile.querySelectorAll('.player');
                existingPlayers.forEach(p => p.remove());
            });

            players.forEach((player, index) => {
                const tileIndex = player.position;
                if (tileIndex >= 0 && tileIndex < boardPath.length) {
                    const tileCoords = boardPath[tileIndex];
                    const tileElement = boardDiv.querySelector(`[data-row="${tileCoords.row}"][data-col="${tileCoords.col}"]`);
                    if (tileElement) {
                        const playerEl = document.createElement('div');
                        playerEl.classList.add('player', `player-${index + 1}`);
                        playerEl.textContent = index + 1;
                        tileElement.appendChild(playerEl);
                    }
                }
            });
        }
        
        function updateUI() {
            renderBoard();
            currentPlayerText.textContent = players[currentPlayerIndex].id;
            
            if (players[0].position >= boardPath.length - 1 || players[1].position >= boardPath.length - 1) {
                rollDiceBtn.disabled = true;
                disableDiceChoices();
            } else {
                rollDiceBtn.disabled = false;
                disableDiceChoices();
            }
        }

        function disableDiceChoices() {
            greenDiceDiv.disabled = true;
            yellowDiceDiv.disabled = true;
            redDiceDiv.disabled = true;
        }

        function enableDiceChoices() {
            greenDiceDiv.disabled = false;
            yellowDiceDiv.disabled = false;
            redDiceDiv.disabled = false;

            const player = players[currentPlayerIndex];
            if (player.canOnlyUseGreen) {
                yellowDiceDiv.disabled = true;
                redDiceDiv.disabled = true;
            }
            if (player.canOnlyUseRed) {
                greenDiceDiv.disabled = true;
                yellowDiceDiv.disabled = true;
            }
        }

        function showMessage(msg) {
            messageBox.textContent = msg;
        }

        function showActionCardModal(cardText) {
            actionCardText.textContent = cardText;
            actionCardModal.classList.remove('hidden');
        }

        // Green die is weighted towards 1, 2, 3
        function rollGreenDice() {
            const weightedRolls = [1, 2, 3, 1, 2, 3, 4, 5, 6];
            return weightedRolls[Math.floor(Math.random() * weightedRolls.length)];
        }

        // Yellow die is a normal, fair die (1-6)
        function rollYellowDice() {
            return Math.floor(Math.random() * 6) + 1;
        }

        // Red die is weighted towards 4, 5, 6
        function rollRedDice() {
            const weightedRolls = [1, 2, 3, 4, 5, 6, 4, 5, 6];
            return weightedRolls[Math.floor(Math.random() * weightedRolls.length)];
        }

        function handleDiceChoice(diceType, diceElement) {
            if (!isChoosingDice) return;
            isChoosingDice = false;

            const player = players[currentPlayerIndex];
            if (player.skipTurn) {
                showMessage(`Player ${player.id}'s turn is skipped!`);
                player.skipTurn = false;
                endTurn();
                return;
            }

            const rollResult = diceResults[diceType];
            chosenDiceType = diceType;
            lastRoll = rollResult;
            
            // Display the chosen die's number
            diceElement.textContent = rollResult;

            // Disable all dice to prevent multiple clicks
            disableDiceChoices();
            rollDiceBtn.disabled = true;
            
            setTimeout(() => {
                player.position += lastRoll;
                
                // Clear the dice displays for the next turn
                greenDiceDiv.textContent = "";
                yellowDiceDiv.textContent = "";
                redDiceDiv.textContent = "";

                if (player.position >= boardPath.length - 1) {
                    player.position = boardPath.length - 1;
                    showMessage(`Player ${player.id} has reached the finish line and won!`);
                    updateUI();
                    return;
                }
                
                showMessage(`Player ${player.id} chose the ${chosenDiceType} die and rolled a ${lastRoll}.`);
                
                // First, render the player on the new tile before showing a potential action card
                updateUI();

                applyTileEffect(lastRoll);
            }, 1000); // Wait for 1 second
        }

        function applyTileEffect(rolledNumber) {
            const player = players[currentPlayerIndex];
            const tileIndex = player.position;
            const tileCoords = boardPath[tileIndex];
            const tileValue = boardData[tileCoords.row][tileCoords.col];
            const opponentIndex = (currentPlayerIndex + 1) % players.length;
            const opponent = players[opponentIndex];
            let cardText = '';

            if (tileValue === '-') {
                if (player.hasProtection) {
                    showMessage(`Player ${player.id} landed on a negative tile but was protected!`);
                    player.hasProtection = false;
                } else {
                    let moveBack = 0;
                    if (chosenDiceType === 'green') {
                        moveBack = 2;
                    } else if (chosenDiceType === 'yellow') {
                        moveBack = 4;
                    } else if (chosenDiceType === 'red') {
                        moveBack = 8;
                    }
                    player.position = Math.max(0, player.position - moveBack);
                    showMessage(`Player ${player.id} landed on a penalty tile and moved back ${moveBack} steps!`);
                }
                // End the turn immediately after a negative tile effect
                endTurn();
            } else if (tileValue === 'Action') {
                const randomCard = actionCards[Math.floor(Math.random() * actionCards.length)];
                cardText = randomCard;

                // Show the modal before applying the effect
                showActionCardModal(cardText);

                // Store the effect and roll result for when the modal is closed
                actionCardModal.dataset.cardEffect = cardText;
                actionCardModal.dataset.rolledNumber = rolledNumber;
                
            } else {
                // If the tile is a normal one, just end the turn
                endTurn();
            }
            
        }

        function applyActionCardEffect(cardText, rolledNumber) {
            const player = players[currentPlayerIndex];
            const opponentIndex = (currentPlayerIndex + 1) % players.length;
            const opponent = players[opponentIndex];
            rolledNumber = parseInt(rolledNumber);

            switch(cardText) {
                case "Skip opponent's turn":
                    opponent.skipTurn = true;
                    showMessage(`Action Card: ${cardText}! Player ${opponent.id}'s turn will be skipped.`);
                    break;
                case "Move forward 3 additional spaces":
                    player.position += 3;
                    showMessage(`Action Card: ${cardText}! You moved forward 3 additional spaces.`);
                    break;
                case "Your opponent is one step behind you":
                    opponent.position = Math.max(0, player.position - 1);
                    showMessage(`Action Card: ${cardText}! Player ${opponent.id} is now one step behind you.`);
                    break;
                case "Move forward one space":
                    player.position += 1;
                    showMessage(`Action Card: ${cardText}! You moved forward one space.`);
                    break;
                case "Swap position with ur opponent":
                    const tempPos = player.position;
                    player.position = opponent.position;
                    opponent.position = tempPos;
                    showMessage(`Action Card: ${cardText}! You swapped positions with your opponent.`);
                    break;
                case "Odd or even: if odd Move backwards if even Move forward":
                    const oddEvenRoll = rollYellowDice();
                    if (oddEvenRoll % 2 === 0) {
                        player.position += oddEvenRoll;
                        showMessage(`Action Card: ${cardText}! Rolled an even ${oddEvenRoll}! Move forward ${oddEvenRoll} spaces.`);
                    } else {
                        player.position = Math.max(0, player.position - oddEvenRoll);
                        showMessage(`Action Card: ${cardText}! Rolled an odd ${oddEvenRoll}! Move backward ${oddEvenRoll} spaces.`);
                    }
                    break;
                case "Double dice: roll Two dice at once and add both numbers rolled.":
                    const roll1 = rollYellowDice();
                    const roll2 = rollYellowDice();
                    const totalRoll = roll1 + roll2;
                    player.position += totalRoll;
                    showMessage(`Action Card: ${cardText}! Rolled a ${roll1} and a ${roll2}! Move forward ${totalRoll} spaces.`);
                    break;
                case "Trip: Move back the same number you rolled.":
                    player.position = Math.max(0, player.position - rolledNumber);
                    showMessage(`Action Card: ${cardText}! You moved back ${rolledNumber} spaces.`);
                    break;
                case "Weak roll: can only roll the Green die next turn":
                    opponent.canOnlyUseGreen = true;
                    showMessage(`Action Card: ${cardText}! Player ${opponent.id} can only use the green die next turn.`);
                    break;
                case "Risk Roll: can only roll the red die next turn":
                    opponent.canOnlyUseRed = true;
                    showMessage(`Action Card: ${cardText}! Player ${opponent.id} can only use the red die next turn.`);
                    break;
                case "6 or nothing: have to roll a 6 to proceed. Red die is unusable.":
                    let foundSix = false;
                    for (let i = 0; i < 5; i++) {
                        const luckyRoll = Math.floor(Math.random() * 6) + 1; // Fixed: now can roll a 6
                        if (luckyRoll === 6) {
                            player.position += 6;
                            foundSix = true;
                            break;
                        }
                    }
                    if (foundSix) {
                        showMessage(`Action Card: ${cardText}! You rolled a 6 and moved forward 6 spaces.`);
                    } else {
                        showMessage(`Action Card: ${cardText}! You failed to roll a 6. No movement this turn.`);
                    }
                    break;
                case "Protection: roll the dice and if it lands on Negative tile, ignore the effect.":
                    player.hasProtection = true;
                    showMessage(`Action Card: ${cardText}! You are now protected from negative tiles for this turn.`);
                    break;
            }
            
            player.canOnlyUseGreen = false;
            player.canOnlyUseRed = false;
            endTurn();
        }

        function endTurn() {
            currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
            updateUI();
            rollDiceBtn.disabled = false;
        }

        function resetGame() {
            players = [{ position: 0, id: 1, skipTurn: false, canOnlyUseGreen: false, canOnlyUseRed: false, hasProtection: false }, { position: 0, id: 2, skipTurn: false, canOnlyUseGreen: false, canOnlyUseRed: false, hasProtection: false }];
            currentPlayerIndex = 0;
            chosenDiceType = null;
            diceResults = { green: 0, yellow: 0, red: 0 };
            boardData.length = 0;
            boardPath.length = 0;
            
            const generatedData = generateBoardData();
            boardData.push(...generatedData);
            
            showMessage("New game started! Roll the dice to begin.");
            updateUI();
        }

        // Event Listeners
        rollDiceBtn.addEventListener('click', () => {
            // Roll all three dice and store the results without displaying
            diceResults.green = rollGreenDice();
            diceResults.yellow = rollYellowDice();
            diceResults.red = rollRedDice();
            
            rollDiceBtn.disabled = true;
            enableDiceChoices();
            isChoosingDice = true;
            showMessage(`Player ${players[currentPlayerIndex].id}, choose a die to move!`);
        });

        greenDiceDiv.addEventListener('click', () => handleDiceChoice('green', greenDiceDiv));
        yellowDiceDiv.addEventListener('click', () => handleDiceChoice('yellow', yellowDiceDiv));
        redDiceDiv.addEventListener('click', () => handleDiceChoice('red', redDiceDiv));

        refreshBtn.addEventListener('click', resetGame);
        closeModalBtn.addEventListener('click', () => {
            actionCardModal.classList.add('hidden');
            const cardEffect = actionCardModal.dataset.cardEffect;
            const rolledNumber = actionCardModal.dataset.rolledNumber;
            applyActionCardEffect(cardEffect, rolledNumber);
        });
        
        // Initial setup
        const generatedData = generateBoardData();
        boardData.push(...generatedData);
        updateUI();
    </script>
</body>
</html>


